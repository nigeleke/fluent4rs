<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="//! Derived from Project Fluent //! fluent.ebnf"><title>fluent4rs::ast - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="fluent4rs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.0 (9fc6b4312 2025-01-07)" data-channel="1.84.0" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../fluent4rs/index.html">fluent4rs</a><span class="version">0.1.30</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module ast</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate fluent4rs</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">fluent4rs</a></span><h1>Module <span>ast</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/fluent4rs/ast/mod.rs.html#1-65">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>//! Derived from <a href="https://github.com/projectfluent/">Project Fluent</a>
//! <a href="https://github.com/projectfluent/fluent/blob/master/spec/fluent.ebnf">fluent.ebnf</a></p>
<p>use super::ast::*;</p>
<p>use pom::utf8::*;</p>
<p>/// # Grammar
///
/// An FTL file defines a <a href="struct.Resource.html" title="struct fluent4rs::ast::Resource">Resource</a> consisting of entries.
///
/// <a href="struct.Resource.html" title="struct fluent4rs::ast::Resource">Resource</a> ::= (<a href="enum.Entry.html" title="enum fluent4rs::ast::Entry">Entry</a> | blank_block | <a href="struct.Junk.html" title="struct fluent4rs::ast::Junk">Junk</a>)*
pub fn resource&lt;’a&gt;() -&gt; Parser&lt;’a, Resource&gt; {
(entry().map(ResourceItem::Entry)
| blank_block().map(ResourceItem::BlankBlock)
| junk().map(ResourceItem::Junk))
.repeat(0..)
.map(Resource::from)
.name(stringify!(resource))
}</p>
<p>/// Entries are the main building blocks of Fluent. They define translations and
/// contextual and semantic information about the translations. During the AST
/// construction, adjacent comment lines of the same comment type (defined by
/// the number of #) are joined together. Single-# comments directly preceding
/// Messages and Terms are attached to the Message or Term and are not
/// standalone Entries.
///
/// <a href="enum.Entry.html" title="enum fluent4rs::ast::Entry">Entry</a> ::= (<a href="struct.Message.html" title="struct fluent4rs::ast::Message">Message</a> line_end)
///    | (<a href="struct.Term.html" title="struct fluent4rs::ast::Term">Term</a> line_end)
///    | <a href="struct.CommentLine.html" title="struct fluent4rs::ast::CommentLine">CommentLine</a>
fn entry&lt;’a&gt;() -&gt; Parser&lt;’a, Entry&gt; {
((message() + line_end()).map(|(m, _)| Entry::Message(m))
| (term() + line_end()).map(|(t, _)| Entry::Term(t))
| (comment_line()).map(Entry::CommentLine))
.name(stringify!(entry))
}</p>
<p>/// <a href="struct.Message.html" title="struct fluent4rs::ast::Message">Message</a> ::= <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a> blank_inline? “=” blank_inline? ((<a href="struct.Pattern.html" title="struct fluent4rs::ast::Pattern">Pattern</a> <a href="struct.Attribute.html" title="struct fluent4rs::ast::Attribute">Attribute</a>*) | (Attribute+))
fn message&lt;’a&gt;() -&gt; Parser&lt;‘a, Message&gt; {
(identifier()
+ blank_inline().opt()
+ sym(’=’)
+ blank_inline().opt()
+ ((pattern() + attribute().repeat(0..)).map(|(p, a)| MessageArguments::Patterned(p, a))
| attribute().repeat(1..).map(MessageArguments::Plain)))
.map(|((((i, _), _), _), a)| Message::new(i, a))
.name(stringify!(message))
}</p>
<p>/// <a href="struct.Term.html" title="struct fluent4rs::ast::Term">Term</a> ::= “-” <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a> blank_inline? “=” blank_inline? <a href="struct.Pattern.html" title="struct fluent4rs::ast::Pattern">Pattern</a> <a href="struct.Attribute.html" title="struct fluent4rs::ast::Attribute">Attribute</a>*
fn term&lt;’a&gt;() -&gt; Parser&lt;‘a, Term&gt; {
(sym(’-‘)
+ identifier()
+ blank_inline().opt()
+ sym(’=’)
+ blank_inline().opt()
+ pattern()
+ attribute().repeat(0..))
.map(|((((((_, i), _), _), _), p), a)| Term::new(i, p, a))
.name(stringify!(term))
}</p>
<p>/// Adjacent comment lines of the same comment type are joined together during
/// the AST construction.
///
/// <a href="struct.CommentLine.html" title="struct fluent4rs::ast::CommentLine">CommentLine</a> ::= (“###” | “##” | “#”) (“\u0020” comment_char*)? line_end
fn comment_line&lt;’a&gt;() -&gt; Parser&lt;‘a, CommentLine&gt; {
((seq(“###”) | seq(“##”) | seq(“#”))
+ (sym(’\u{0020}’) + comment_char().repeat(0..)).opt()
+ line_end())
.map(|((lead, space_comment), <em>)| {
let comment = space_comment.map(|(</em>, c)| c.join(“”));
CommentLine::new(lead.into(), comment)
})
.name(stringify!(comment_line))
}</p>
<p>/// comment_char ::= any_char - line_end
fn comment_char&lt;’a&gt;() -&gt; Parser&lt;’a, String&gt; {
(!line_end() * any()).map(String::from)
}</p>
<p>/// Junk represents unparsed content.
///
/// Junk is parsed line-by-line until a line is found which looks like it might
/// be a beginning of a new message, term, or a comment. Any whitespace
/// following a broken Entry is also considered part of Junk.
///
/// <a href="../parser/struct.Parser.html#method.parse" title="associated function fluent4rs::parser::Parser::parse">Parser::parse</a> treats Junk as a
/// [ParseError](crate::parser::ParseError.
///
/// <a href="crate::Parser::parse_with_junk">Parser::parse_with_junk</a> will return <a href="struct.Junk.html" title="struct fluent4rs::ast::Junk">Junk</a>
/// in the <a href="struct.Resource.html" title="struct fluent4rs::ast::Resource">Resource</a>.
///
/// <a href="struct.Junk.html" title="struct fluent4rs::ast::Junk">Junk</a> ::= junk_line (junk_line - “#” - “-” - [a-zA-Z])*
fn junk&lt;’a&gt;() -&gt; Parser&lt;‘a, Junk&gt; {
(junk_line()
+ (!(sym(’#‘) | sym(’-’) | is_a(|c| c.is_ascii_alphabetic())) * junk_line()).repeat(0..))
.map(|(head, tail)| {
let mut junk = Vec::from([head]);
junk.extend(tail);
Junk::from(junk.as_slice())
})
.name(stringify!(junk))
}</p>
<p>/// junk_line ::= /[^\n]*/ (“\u000A” | EOF)
fn junk_line&lt;’a&gt;() -&gt; Parser&lt;‘a, String&gt; {
((none_of(“\n”).repeat(0..)) + sym(’\u{000a}’))
.collect()
.map(String::from)
}</p>
<p>/// Attributes of Messages and Terms.
///
/// <a href="struct.Attribute.html" title="struct fluent4rs::ast::Attribute">Attribute</a> ::= line_end blank? “.” <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a> blank_inline? “=” blank_inline? <a href="struct.Pattern.html" title="struct fluent4rs::ast::Pattern">Pattern</a>
fn attribute&lt;’a&gt;() -&gt; Parser&lt;‘a, Attribute&gt; {
(line_end()
+ blank().opt()
+ sym(’.‘)
+ identifier()
+ blank_inline().opt()
+ sym(’=’)
+ blank_inline().opt()
+ pattern())
.map(|(((((((_, _), _), i), _), _), _), p)| Attribute::new(i, p))
.name(stringify!(attribute))
}</p>
<p>/// Patterns are values of Messages, Terms, Attributes and Variants.
///
/// <a href="struct.Pattern.html" title="struct fluent4rs::ast::Pattern">Pattern</a> ::= <a href="enum.PatternElement.html" title="enum fluent4rs::ast::PatternElement">PatternElement</a>+
fn pattern&lt;’a&gt;() -&gt; Parser&lt;’a, Pattern&gt; {
(pattern_element().repeat(1..))
.map(|pes| Pattern::from(pes.as_slice()))
.name(stringify!(pattern))
}</p>
<p>/// TextElement and Placeable can occur inline or as block.
/// Text needs to be indented and start with a non-special character.
/// Placeables can start at the beginning of the line or be indented.
/// Adjacent TextElements are joined in AST creation.
///
/// <a href="enum.PatternElement.html" title="enum fluent4rs::ast::PatternElement">PatternElement</a> ::= inline_text
///    | block_text
///    | inline_placeable
///    | block_placeable
fn pattern_element&lt;’a&gt;() -&gt; Parser&lt;’a, PatternElement&gt; {
(inline_text().map(PatternElement::InlineText)
| block_text().map(PatternElement::BlockText)
| call(inline_placeable).map(PatternElement::InlinePlaceable)
| block_placeable().map(PatternElement::BlockPlaceable))
.name(stringify!(pattern_element))
}</p>
<p>/// inline_text ::= text_char+
fn inline_text&lt;’a&gt;() -&gt; Parser&lt;’a, InlineText&gt; {
(text_char().repeat(1..)).collect().map(InlineText::from)
}</p>
<p>/// block_text ::= blank_block blank_inline indented_char inline_text?
fn block_text&lt;’a&gt;() -&gt; Parser&lt;’a, BlockText&gt; {
(blank_block() + blank_inline() + indented_char() + inline_text().opt())
.collect()
.map(BlockText::from)
}</p>
<p>/// inline_placeable ::= “{” blank? (<a href="struct.SelectExpression.html" title="struct fluent4rs::ast::SelectExpression">SelectExpression</a> | <a href="enum.InlineExpression.html" title="enum fluent4rs::ast::InlineExpression">InlineExpression</a>) blank? “}”
fn inline_placeable&lt;’a&gt;() -&gt; Parser&lt;‘a, InlinePlaceable&gt; {
(sym(’{‘)
+ blank().opt()
+ (call(select_expression).map(InlinePlaceable::SelectExpression)
| call(inline_expression).map(InlinePlaceable::InlineExpression))
+ blank().opt()
+ sym(’}’))
.map(|((((_, _), ip), _), _)| ip)
}</p>
<p>/// block_placeable ::= blank_block blank_inline? inline_placeable
fn block_placeable&lt;’a&gt;() -&gt; Parser&lt;’a, BlockPlaceable&gt; {
((blank_block() + blank_inline().opt()).collect() + call(inline_placeable))
.map(|(bb, ip)| BlockPlaceable::new(bb.into(), ip))
}</p>
<p>/// Rules for validating expressions in Placeables and as selectors of
/// SelectExpressions are documented in <a href="https://github.com/projectfluent/fluent/blob/master/spec/valid.md">spec/valid.md</a> and enforced in
/// <a href="https://github.com/projectfluent/fluent/blob/master/syntax/abstract.js">syntax/abstract.js</a>.
///
/// <a href="enum.InlineExpression.html" title="enum fluent4rs::ast::InlineExpression">InlineExpression</a> ::= <a href="crate::ast::String:Literal">StringLiteral</a>
///    | <a href="struct.NumberLiteral.html" title="struct fluent4rs::ast::NumberLiteral">NumberLiteral</a>
///    | <a href="struct.FunctionReference.html" title="struct fluent4rs::ast::FunctionReference">FunctionReference</a>
///    | <a href="struct.MessageReference.html" title="struct fluent4rs::ast::MessageReference">MessageReference</a>
///    | <a href="struct.TermReference.html" title="struct fluent4rs::ast::TermReference">TermReference</a>
///    | <a href="struct.VariableReference.html" title="struct fluent4rs::ast::VariableReference">VariableReference</a>
///    | inline_placeable
fn inline_expression&lt;’a&gt;() -&gt; Parser&lt;’a, InlineExpression&gt; {
(string_literal().map(InlineExpression::StringLiteral)
| number_literal().map(InlineExpression::NumberLiteral)
| function_reference().map(InlineExpression::FunctionReference)
| message_reference().map(InlineExpression::MessageReference)
| term_reference().map(InlineExpression::TermReference)
| variable_reference().map(InlineExpression::VariableReference)
| call(inline_placeable).map(|ip| InlineExpression::InlinePlaceable(Box::new(ip))))
.name(stringify!(inline_expression))
}</p>
<p>/// ## Literals
///
/// <a href="struct.StringLiteral.html" title="struct fluent4rs::ast::StringLiteral">StringLiteral</a> ::= “"” quoted_char* “"”
fn string_literal&lt;’a&gt;() -&gt; Parser&lt;‘a, StringLiteral&gt; {
(sym(’“‘) * quoted_char().repeat(0..).collect() - sym(’”’))
.map(StringLiteral::from)
.name(stringify!(string_literal))
}</p>
<p>/// <a href="struct.NumberLiteral.html" title="struct fluent4rs::ast::NumberLiteral">NumberLiteral</a> ::= “-”? digits (“.” digits)?
fn number_literal&lt;’a&gt;() -&gt; Parser&lt;‘a, NumberLiteral&gt; {
(sym(’-‘).opt() + digits() + (sym(’.’) + digits()).opt())
.collect()
.map(NumberLiteral::from)
.name(stringify!(number_literal))
}</p>
<p>/// ## Inline Expressions
///
/// <a href="struct.FunctionReference.html" title="struct fluent4rs::ast::FunctionReference">FunctionReference</a> ::= <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a> <a href="struct.CallArguments.html" title="struct fluent4rs::ast::CallArguments">CallArguments</a>
fn function_reference&lt;’a&gt;() -&gt; Parser&lt;’a, FunctionReference&gt; {
(identifier() + call_arguments())
.map(|(i, ca)| FunctionReference::new(i, ca))
.name(stringify!(function_reference))
}</p>
<p>/// <a href="struct.MessageReference.html" title="struct fluent4rs::ast::MessageReference">MessageReference</a> ::= <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a> <a href="struct.AttributeAccessor.html" title="struct fluent4rs::ast::AttributeAccessor">AttributeAccessor</a>?
fn message_reference&lt;’a&gt;() -&gt; Parser&lt;’a, MessageReference&gt; {
(identifier() + attribute_accessor().opt())
.map(|(i, aa)| MessageReference::new(i, aa))
.name(stringify!(message_reference))
}</p>
<p>/// <a href="struct.TermReference.html" title="struct fluent4rs::ast::TermReference">TermReference</a> ::= “-” <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a> <a href="struct.AttributeAccessor.html" title="struct fluent4rs::ast::AttributeAccessor">AttributeAccessor</a>? <a href="struct.CallArguments.html" title="struct fluent4rs::ast::CallArguments">CallArguments</a>?
fn term_reference&lt;’a&gt;() -&gt; Parser&lt;‘a, TermReference&gt; {
(sym(’-’) + identifier() + attribute_accessor().opt() + call_arguments().opt())
.map(|(((_, i), aa), ca)| TermReference::new(i, aa, ca))
.name(stringify!(term_reference))
}</p>
<p>/// <a href="struct.VariableReference.html" title="struct fluent4rs::ast::VariableReference">VariableReference</a> ::= “$” <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a>
fn variable_reference&lt;’a&gt;() -&gt; Parser&lt;‘a, VariableReference&gt; {
(sym(’$’) + identifier())
.map(|(_, i)| VariableReference::from(i))
.name(stringify!(variable_reference))
}</p>
<p>/// <a href="struct.AttributeAccessor.html" title="struct fluent4rs::ast::AttributeAccessor">AttributeAccessor</a> ::= “.” <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a>
fn attribute_accessor&lt;’a&gt;() -&gt; Parser&lt;‘a, AttributeAccessor&gt; {
(sym(’.’) + identifier())
.map(|(_, i)| AttributeAccessor::from(i))
.name(stringify!(attribute_accessor))
}</p>
<p>/// <a href="crate::ast::CallArguements">CallArguments</a> ::= blank? “(” blank? argument_list blank? “)”
fn call_arguments&lt;’a&gt;() -&gt; Parser&lt;‘a, CallArguments&gt; {
(blank().opt() + sym(’(‘) + blank().opt() + argument_list() + blank().opt() + sym(’)’))
.map(|(((((_, _), _), al), _), _)| CallArguments::from(al.as_slice()))
.name(stringify!(call_arguments))
}</p>
<p>/// argument_list ::= (<a href="enum.Argument.html" title="enum fluent4rs::ast::Argument">Argument</a> blank? “,” blank?)* <a href="enum.Argument.html" title="enum fluent4rs::ast::Argument">Argument</a>?
fn argument_list&lt;’a&gt;() -&gt; Parser&lt;‘a, Vec<Argument>&gt; {
((argument() + blank().opt() + sym(’,’) + blank().opt()).repeat(0..) + argument().opt()).map(
|(args, arg)| {
let mut args = Vec::from_iter(args.into_iter().map(|(((a, _), _), _)| a));
if let Some(arg) = arg {
args.push(arg);
}
args
},
)
}</p>
<p>/// <a href="enum.Argument.html" title="enum fluent4rs::ast::Argument">Argument</a> ::= <a href="struct.NamedArgument.html" title="struct fluent4rs::ast::NamedArgument">NamedArgument</a>
///    | <a href="enum.InlineExpression.html" title="enum fluent4rs::ast::InlineExpression">InlineExpression</a>
fn argument&lt;’a&gt;() -&gt; Parser&lt;’a, Argument&gt; {
named_argument().map(Argument::NamedArgument)
| call(inline_expression)
.map(Argument::InlineExpression)
.name(stringify!(argument))
}</p>
<p>/// <a href="struct.NamedArgument.html" title="struct fluent4rs::ast::NamedArgument">NamedArgument</a> ::= <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a> blank? “:” blank? (<a href="struct.StringLiteral.html" title="struct fluent4rs::ast::StringLiteral">StringLiteral</a> | <a href="struct.NumberLiteral.html" title="struct fluent4rs::ast::NumberLiteral">NumberLiteral</a>)
fn named_argument&lt;’a&gt;() -&gt; Parser&lt;‘a, NamedArgument&gt; {
(identifier()
+ blank().opt()
+ sym(’:’)
+ blank().opt()
+ (string_literal().map(Literal::from) | number_literal().map(Literal::from)))
.map(|((((i, _), _), _), l)| NamedArgument::new(i, l))
.name(stringify!(named_argument))
}</p>
<p>/// ## Block Expressions
///
/// <a href="struct.SelectExpression.html" title="struct fluent4rs::ast::SelectExpression">SelectExpression</a> ::= <a href="enum.InlineExpression.html" title="enum fluent4rs::ast::InlineExpression">InlineExpression</a> blank? “-&gt;” blank_inline? variant_list
fn select_expression&lt;’a&gt;() -&gt; Parser&lt;’a, SelectExpression&gt; {
(call(inline_expression) + blank().opt() + seq(“-&gt;”) + blank_inline().opt() + variant_list())
.map(|((((ie, _), _), _), vl)| SelectExpression::new(ie, vl))
.name(stringify!(select_expression))
}</p>
<p>/// variant_list ::= <a href="struct.Variant.html" title="struct fluent4rs::ast::Variant">Variant</a>* <a href="struct.DefaultVariant.html" title="struct fluent4rs::ast::DefaultVariant">DefaultVariant</a> <a href="struct.Variant.html" title="struct fluent4rs::ast::Variant">Variant</a>* line_end
fn variant_list&lt;’a&gt;() -&gt; Parser&lt;’a, VariantList&gt; {
(variant().repeat(0..) + default_variant() + variant().repeat(0..) + line_end())
.map(|(((va, dv), vz), _)| VariantList::new(va, dv, vz))
}</p>
<p>/// <a href="struct.Variant.html" title="struct fluent4rs::ast::Variant">Variant</a> ::= line_end blank? <a href="enum.VariantKey.html" title="enum fluent4rs::ast::VariantKey">VariantKey</a> blank_inline? <a href="struct.Pattern.html" title="struct fluent4rs::ast::Pattern">Pattern</a>
fn variant&lt;’a&gt;() -&gt; Parser&lt;’a, Variant&gt; {
(line_end() + blank().opt() + variant_key() + blank_inline().opt() + pattern())
.map(|((((_, _), vk), _), p)| Variant::new(vk, p))
.name(stringify!(variant))
}</p>
<p>/// <a href="struct.DefaultVariant.html" title="struct fluent4rs::ast::DefaultVariant">DefaultVariant</a> ::= line_end blank? “<em>” <a href="enum.VariantKey.html" title="enum fluent4rs::ast::VariantKey">VariantKey</a> blank_inline? <a href="struct.Pattern.html" title="struct fluent4rs::ast::Pattern">Pattern</a>
fn default_variant&lt;’a&gt;() -&gt; Parser&lt;‘a, DefaultVariant&gt; {
(line_end() + blank().opt() + sym(’</em>’) + variant_key() + blank_inline().opt() + pattern())
.map(|(((((_, _), _), vk), _), p)| DefaultVariant::new(vk, p))
.name(stringify!(default_variant))
}</p>
<p>/// <a href="enum.VariantKey.html" title="enum fluent4rs::ast::VariantKey">VariantKey</a> ::= “[” blank? (<a href="struct.NumberLiteral.html" title="struct fluent4rs::ast::NumberLiteral">NumberLiteral</a> | <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a>) blank? “]”
fn variant_key&lt;’a&gt;() -&gt; Parser&lt;‘a, VariantKey&gt; {
(sym(’[‘)
+ (number_literal().map(VariantKey::NumberLiteral)
| identifier().map(VariantKey::Identifier))
+ blank().opt()
+ sym(’]’))
.map(|(((_, vk), _), _)| vk)
}</p>
<p>/// ## Identifier
///
/// <a href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a> ::= [a-zA-Z] [a-zA-Z0-9_-]*
fn identifier&lt;’a&gt;() -&gt; Parser&lt;’a, Identifier&gt; {
(is_a(|c| c.is_ascii_alphabetic())
+ is_a(|c| c.is_ascii_alphanumeric() || c == ‘_’ || c == ‘-’).repeat(0..))
.collect()
.map(Identifier::from)
.name(stringify!(identifier))
}</p>
<p>/// ## Content Characters
///
/// Translation content can be written using any Unicode characters. However,
/// some characters are considered special depending on the type of content
/// they’re in. See text_char and quoted_char for more information.
///
/// Some Unicode characters, even if allowed, should be avoided in Fluent
/// resources. See <a href="https://github.com/projectfluent/fluent/blob/master/spec/recommendations.md">spec/recommendations.md</a>.
///
/// any_char ::= [\u{0}-\u{10FFFF}]
fn any_char&lt;’a&gt;() -&gt; Parser&lt;’a, String&gt; {
let range = ‘\u{0000}’..=‘\u{10ffff}’;
is_a(move |c| range.contains(&amp;c))
.collect()
.map(String::from)
}</p>
<p>/// ## Text elements
///
/// The primary storage for content are text elements. Text elements are not
/// delimited with quotes and may span multiple lines as long as all lines are
/// indented. The opening brace ({) marks a start of a placeable in the pattern
/// and may not be used in text elements verbatim. Due to the indentation
/// requirement some text characters may not appear as the first character on a
/// new line.
///
/// special_text_char ::= “{”
///    | “}”
fn special_text_char&lt;’a&gt;() -&gt; Parser&lt;‘a, String&gt; {
(sym(’{‘) | sym(’}’)).collect().map(String::from)
}</p>
<p>/// text_char ::= any_char - special_text_char - line_end
fn text_char&lt;’a&gt;() -&gt; Parser&lt;’a, String&gt; {
!(special_text_char() | line_end()) * any_char()
}</p>
<p>/// indented_char ::= text_char - “[” - “<em>” - “.”
fn indented_char&lt;’a&gt;() -&gt; Parser&lt;’a, String&gt; {
!one_of(“[</em>.”) * text_char()
}</p>
<p>/// ## String literals
///
/// For special-purpose content, quoted string literals can be used where text
/// elements are not a good fit. String literals are delimited with double
/// quotes and may not contain line breaks. String literals use the backslash
/// () as the escape character. The literal double quote can be inserted via
/// the " escape sequence. The literal backslash can be inserted with \. The
/// literal opening brace ({) is allowed in string literals because they may not
/// comprise placeables.
///
/// special_quoted_char ::= “"”
///    | “\”
fn special_quoted_char&lt;’a&gt;() -&gt; Parser&lt;‘a, String&gt; {
(sym(’“‘) | sym(’\’)).map(|c| c.to_string())
}</p>
<p>/// special_escape ::= “\” special_quoted_char
fn special_escape&lt;’a&gt;() -&gt; Parser&lt;‘a, String&gt; {
(sym(’\’) + special_quoted_char())
.collect()
.map(String::from)
}</p>
<p>/// unicode_escape ::= (“\u” /[0-9a-fA-F]{4}/)
///    | (“\U” /[0-9a-fA-F]{6}/)
fn unicode_escape&lt;’a&gt;() -&gt; Parser&lt;’a, String&gt; {
((seq(“\u”) + is_a(|c| c.is_ascii_hexdigit()).repeat(4))
| (seq(“\U”) + is_a(|c| c.is_ascii_hexdigit()).repeat(6)))
.collect()
.map(String::from)
}</p>
<p>/// quoted_char ::= (any_char - special_quoted_char - line_end)
///    | special_escape
///    | unicode_escape
fn quoted_char&lt;’a&gt;() -&gt; Parser&lt;’a, String&gt; {
(!(special_quoted_char() | line_end()) * any_char()) | special_escape() | unicode_escape()
}</p>
<p>/// ## Numbers
///
/// digits ::= [0-9]+
fn digits&lt;’a&gt;() -&gt; Parser&lt;’a, String&gt; {
is_a(|c| c.is_ascii_digit())
.repeat(1..)
.collect()
.map(String::from)
}</p>
<p>/// ### Whitespace
///
/// blank_inline ::= “\u0020”+
fn blank_inline&lt;’a&gt;() -&gt; Parser&lt;‘a, String&gt; {
sym(’\u{0020}’).repeat(1..).map(String::from_iter)
}</p>
<p>/// line_end ::= “\u000D\u000A”
///    | “\u000A”
///    | EOF
fn line_end&lt;’a&gt;() -&gt; Parser&lt;‘a, String&gt; {
(sym(’\u{000d}‘) + sym(’\u{000a}‘))
.collect()
.map(String::from)
| sym(’\u{000a}’).collect().map(String::from)
}</p>
<p>/// blank_block ::= (blank_inline? line_end)+
fn blank_block&lt;’a&gt;() -&gt; Parser&lt;’a, String&gt; {
((blank_inline().opt() + line_end()).repeat(1..))
.collect()
.map(String::from)
}</p>
<p>/// blank ::= (blank_inline | line_end)+
fn blank&lt;’a&gt;() -&gt; Parser&lt;’a, String&gt; {
((blank_inline() | line_end()).repeat(1..))
.collect()
.map(String::from)
}</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Attribute.html" title="struct fluent4rs::ast::Attribute">Attribute</a></div></li><li><div class="item-name"><a class="struct" href="struct.AttributeAccessor.html" title="struct fluent4rs::ast::AttributeAccessor">Attribute<wbr>Accessor</a></div></li><li><div class="item-name"><a class="struct" href="struct.BlockPlaceable.html" title="struct fluent4rs::ast::BlockPlaceable">Block<wbr>Placeable</a></div></li><li><div class="item-name"><a class="struct" href="struct.BlockText.html" title="struct fluent4rs::ast::BlockText">Block<wbr>Text</a></div></li><li><div class="item-name"><a class="struct" href="struct.CallArguments.html" title="struct fluent4rs::ast::CallArguments">Call<wbr>Arguments</a></div></li><li><div class="item-name"><a class="struct" href="struct.CommentLine.html" title="struct fluent4rs::ast::CommentLine">Comment<wbr>Line</a></div></li><li><div class="item-name"><a class="struct" href="struct.DefaultVariant.html" title="struct fluent4rs::ast::DefaultVariant">Default<wbr>Variant</a></div></li><li><div class="item-name"><a class="struct" href="struct.FunctionReference.html" title="struct fluent4rs::ast::FunctionReference">Function<wbr>Reference</a></div></li><li><div class="item-name"><a class="struct" href="struct.Identifier.html" title="struct fluent4rs::ast::Identifier">Identifier</a></div></li><li><div class="item-name"><a class="struct" href="struct.InlineText.html" title="struct fluent4rs::ast::InlineText">Inline<wbr>Text</a></div></li><li><div class="item-name"><a class="struct" href="struct.Junk.html" title="struct fluent4rs::ast::Junk">Junk</a></div></li><li><div class="item-name"><a class="struct" href="struct.Message.html" title="struct fluent4rs::ast::Message">Message</a></div></li><li><div class="item-name"><a class="struct" href="struct.MessageReference.html" title="struct fluent4rs::ast::MessageReference">Message<wbr>Reference</a></div></li><li><div class="item-name"><a class="struct" href="struct.NamedArgument.html" title="struct fluent4rs::ast::NamedArgument">Named<wbr>Argument</a></div></li><li><div class="item-name"><a class="struct" href="struct.NumberLiteral.html" title="struct fluent4rs::ast::NumberLiteral">Number<wbr>Literal</a></div></li><li><div class="item-name"><a class="struct" href="struct.Pattern.html" title="struct fluent4rs::ast::Pattern">Pattern</a></div></li><li><div class="item-name"><a class="struct" href="struct.Resource.html" title="struct fluent4rs::ast::Resource">Resource</a></div></li><li><div class="item-name"><a class="struct" href="struct.SelectExpression.html" title="struct fluent4rs::ast::SelectExpression">Select<wbr>Expression</a></div></li><li><div class="item-name"><a class="struct" href="struct.StringLiteral.html" title="struct fluent4rs::ast::StringLiteral">String<wbr>Literal</a></div></li><li><div class="item-name"><a class="struct" href="struct.Term.html" title="struct fluent4rs::ast::Term">Term</a></div></li><li><div class="item-name"><a class="struct" href="struct.TermReference.html" title="struct fluent4rs::ast::TermReference">Term<wbr>Reference</a></div></li><li><div class="item-name"><a class="struct" href="struct.VariableReference.html" title="struct fluent4rs::ast::VariableReference">Variable<wbr>Reference</a></div></li><li><div class="item-name"><a class="struct" href="struct.Variant.html" title="struct fluent4rs::ast::Variant">Variant</a></div></li><li><div class="item-name"><a class="struct" href="struct.VariantList.html" title="struct fluent4rs::ast::VariantList">Variant<wbr>List</a></div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Argument.html" title="enum fluent4rs::ast::Argument">Argument</a></div></li><li><div class="item-name"><a class="enum" href="enum.Entry.html" title="enum fluent4rs::ast::Entry">Entry</a></div></li><li><div class="item-name"><a class="enum" href="enum.InlineExpression.html" title="enum fluent4rs::ast::InlineExpression">Inline<wbr>Expression</a></div></li><li><div class="item-name"><a class="enum" href="enum.InlinePlaceable.html" title="enum fluent4rs::ast::InlinePlaceable">Inline<wbr>Placeable</a></div></li><li><div class="item-name"><a class="enum" href="enum.Literal.html" title="enum fluent4rs::ast::Literal">Literal</a></div></li><li><div class="item-name"><a class="enum" href="enum.PatternElement.html" title="enum fluent4rs::ast::PatternElement">Pattern<wbr>Element</a></div></li><li><div class="item-name"><a class="enum" href="enum.ResourceItem.html" title="enum fluent4rs::ast::ResourceItem">Resource<wbr>Item</a></div></li><li><div class="item-name"><a class="enum" href="enum.VariantKey.html" title="enum fluent4rs::ast::VariantKey">Variant<wbr>Key</a></div></li></ul></section></div></main></body></html>